{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyFGLT: Fast Graphlet Transform in Python","text":"<p>We provide pyFGLT, a wrapper to a C/C++ multi-threaded library, for Fast Graphlet Transform of large, sparse, undirected networks/graphs. Graphlets are used as encoding elements to capture topological connectivity quantitatively and transform a graph \\(G=(V,E)\\) into a \\(|V| \\times K\\) array of graphlet frequencies at all vertices. The \\(K\\)-element vector at each vertex represents the frequencies of induced subgraphs, incident at the vertex, of the graphlet patterns. The transformed data array serves multiple types of network analysis: statistical or/and topological measures, comparison, classification, modeling, feature embedding and dynamic variation, among others. The library pyFGLT is distinguished in the following key aspects. (1) It is based on the fast, sparse and exact transform formulas which are of the lowest time and space complexities among known algorithms, and, at the same time, in ready form for globally streamlined computation in matrix-vector operations. (2) It leverages prevalent multi-core processors, with multi-threaded programming in Cilk, and uses sparse graph computation techniques to deliver high-performance network analysis to individual laptops or desktop computers.</p> <p>A graph element, a.k.a. graphlet, is a connected template graph with a small number of nodes with or without a designated incidence orbit (shown in red below). The graphlet patterns of up to four nodes are shown below.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>Install this library using <code>pip</code>: <pre><code>pip install pyfglt\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p>See the examples under:</p> <ul> <li>Getting started</li> <li>Advanced usage</li> </ul> <p>for a quick start and advanced usage of the library.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use this package, please cite this paper:</p> <pre><code>@article{fglt,\n    author = {Floros, Dimitris and Pitsianis, Nikos and Sun, Xiaobai},\n    journal = {IEEE HPEC},\n    pages = {1--8},\n    title = {{Fast graphlet transform of sparse graphs}},\n    year = {2020}\n}\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#pyfglt.fglt.compute","title":"<code>compute(A, raw=False)</code>","text":"<p>Compute the counts fo the Fast Graphlet Transform.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Union[Graph, csc_matrix]</code> <p>Either the graph as a <code>networkx.Graph</code> object                               or the adjacency matrix of the graph in <code>scipy.sparse.csc_matrix</code> format.</p> required <code>raw</code> <code>bool</code> <p>If True, return both the raw and the net counts of the graphlets.          If False, then return only the normalized counts.          Defaults to False.</p> <code>False</code> <p>Accepts either an undirected, unweighted NetworkX graph or a CSC sparse matrix. If a NetworkX graph is provided, converts it to a CSC adjacency matrix. If a CSC matrix is provided, verifies that it is unweighted and symmetric.</p> <p>Returns:</p> Name Type Description <code>F</code> <code>DataFrame</code> <p>A dataframe with the net counts of the graphlets.</p> <code>F_raw</code> <code>DataFrame</code> <p>A dataframe with the raw counts of the graphlets (if raw=True).</p> Source code in <code>pyfglt/fglt.py</code> <pre><code>@typechecked\ndef compute(A: Union[nx.Graph, csc_matrix], raw: bool = False) -&gt; Union[pd.DataFrame, tuple[pd.DataFrame, pd.DataFrame]]:\n    \"\"\"Compute the counts fo the Fast Graphlet Transform.\n\n    Args:\n        A (Union[nx.Graph, csc_matrix]): Either the graph as a `networkx.Graph` object \n                                         or the adjacency matrix of the graph in `scipy.sparse.csc_matrix` format.\n        raw (bool): If True, return both the raw and the net counts of the graphlets. \n                    If False, then return only the normalized counts. \n                    Defaults to False.\n\n    Accepts either an undirected, unweighted NetworkX graph or a CSC sparse matrix.\n    If a NetworkX graph is provided, converts it to a CSC adjacency matrix.\n    If a CSC matrix is provided, verifies that it is unweighted and symmetric.\n\n    Returns:\n        F (DataFrame): A dataframe with the net counts of the graphlets.\n        F_raw (DataFrame): A dataframe with the raw counts of the graphlets (if raw=True).\n    \"\"\"\n\n    # If input is a NetworkX graph\n    if isinstance(A, nx.Graph):\n        # Ensure it's undirected\n        if A.is_directed():\n            raise ValueError(\"Graph must be undirected.\")\n\n        # Convert to adjacency matrix in CSC format\n        adj_matrix = nx.adjacency_matrix(A)\n        csc_adj = adj_matrix.tocsc()\n\n    # If input is already a CSC matrix\n    elif issparse(A) and isinstance(A, csc_matrix):\n        csc_adj = A  # Use directly\n\n        # Ensure symmetry (A == A.T)\n        if not (abs(csc_adj - csc_adj.T)).nnz == 0:\n            raise ValueError(\"CSC matrix must be symmetric (undirected graph).\")\n\n        # Ensure unweighted (all elements are 0 or 1)\n        if not np.all(np.isin(csc_adj.data, [0, 1])):\n            raise ValueError(\"CSC matrix must be unweighted (contain only 0s and 1s).\")\n\n    else:\n        raise TypeError(\"Input must be either a NetworkX undirected graph or a CSC matrix.\")\n\n    f, fn = _fglt_c.count(csc_adj)\n\n    # cast f and fn to int64\n    f = f.astype(numpy.int64)\n    fn = fn.astype(numpy.int64)\n\n    # transpose f and fn\n    f = f.T\n    fn = fn.T\n\n    # transform to dataframe\n    F  = pd.DataFrame(f, columns=COLUMNS)\n    FN = pd.DataFrame(fn, columns=COLUMNS)\n\n    # set index name to \"Node id (0-based)\"\n    F.index.name = \"Node id (0-based)\"\n    FN.index.name = \"Node id (0-based)\"\n\n    if raw:\n        return FN, F\n    else:\n        return FN\n</code></pre>"},{"location":"api/#pyfglt.fglt.compute_gdd_agreement","title":"<code>compute_gdd_agreement(df_g1, df_g2, bins=None)</code>","text":"<p>Compute Graphlet Degree Distribution (GDD) agreement between two graphs.</p> <p>Parameters:</p> Name Type Description Default <code>df_g1</code> <code>DataFrame</code> <p>Orbit counts for Graph 1 (rows=vertices, columns=orbits).</p> required <code>df_g2</code> <code>DataFrame</code> <p>Orbit counts for Graph 2 (rows=vertices, columns=orbits).</p> required <code>bins</code> <code>Union[int, sequence]</code> <p>Bins for histogram. If None, will try an automatic approach.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>s</code> <code>float</code> <p>The GDD agreement in [0, 1].</p> Source code in <code>pyfglt/fglt.py</code> <pre><code>@typechecked\ndef compute_gdd_agreement(df_g1: pd.DataFrame, df_g2:pd.DataFrame, bins=None):\n    \"\"\"\n    Compute Graphlet Degree Distribution (GDD) agreement between two graphs.\n\n    Args:\n        df_g1 (pd.DataFrame): Orbit counts for Graph 1 (rows=vertices, columns=orbits).\n        df_g2 (pd.DataFrame): Orbit counts for Graph 2 (rows=vertices, columns=orbits).\n        bins (Union[int, sequence]): Bins for histogram. If None, will try an automatic approach.\n\n    Returns:\n        s (float): The GDD agreement in [0, 1].\n    \"\"\"\n    n_orbits = df_g1.shape[1]\n    # We assume df_g1 and df_g2 have the same shape: #orbits = n_orbits\n\n    # We can find a reasonable range for all orbit degrees combined\n    combined_max = max(df_g1.values.max(), df_g2.values.max())\n    if bins is None:\n        # We'll bin from 0 up to the max count + 1\n        bins = np.arange(0, combined_max + 2) - 0.5  # so that each integer is its own bin\n\n    overlaps = []\n\n    for orbit_col in df_g1.columns:\n        # Distribution for Graph 1, orbit_col\n        hist_g1, _ = np.histogram(df_g1[orbit_col], bins=bins, density=True)\n        # Distribution for Graph 2, orbit_col\n        hist_g2, _ = np.histogram(df_g2[orbit_col], bins=bins, density=True)\n\n        # Overlap for this orbit\n        overlap = np.sum(np.minimum(hist_g1, hist_g2))\n        overlaps.append(overlap)\n\n    # Average overlap across orbits\n    gdd_agreement = np.mean(overlaps)\n    return gdd_agreement\n</code></pre>"},{"location":"api/#pyfglt.fglt.compute_graphlet_correlation_matrix","title":"<code>compute_graphlet_correlation_matrix(df_g, method='spearman')</code>","text":"<p>Compute the Graphlet Correlation Matrix (GCM) for a single graph.</p> <p>Parameters:</p> Name Type Description Default <code>df_g</code> <code>DataFrame</code> <p>Orbit counts for a graph (rows=vertices, columns=orbits).</p> required <p>Returns:</p> Name Type Description <code>C</code> <code>DataFrame</code> <p>Correlation matrix of shape (n_orbits, n_orbits).</p> Source code in <code>pyfglt/fglt.py</code> <pre><code>@typechecked\ndef compute_graphlet_correlation_matrix(df_g:pd.DataFrame, method='spearman'):\n    \"\"\"\n    Compute the Graphlet Correlation Matrix (GCM) for a single graph.\n\n    Args:\n        df_g (pd.DataFrame): Orbit counts for a graph (rows=vertices, columns=orbits).\n        method (str) Correlation method. Can be 'pearson', 'spearman', or 'kendall'.\n\n    Returns:\n        C (pd.DataFrame): Correlation matrix of shape (n_orbits, n_orbits).\n    \"\"\"\n    return df_g.iloc[:,1:].corr(method=method)\n</code></pre>"},{"location":"api/#pyfglt.fglt.compute_rgf_distance","title":"<code>compute_rgf_distance(df_g1, df_g2)</code>","text":"<p>Relative Graphlet Frequency (RGF)</p> <p>Parameters:</p> Name Type Description Default <code>df_g1</code> <code>DataFrame</code> <p>Orbit counts for Graph 1 (rows=vertices, columns=orbits).</p> required <code>df_g2</code> <code>DataFrame</code> <p>Orbit counts for Graph 2 (rows=vertices, columns=orbits).</p> required <p>Compute the Relative Graphlet Frequency (RGF) distance between two graphs represented by DataFrames of orbit counts.</p> <p>Returns:</p> Name Type Description <code>d</code> <code>float</code> <p>The RGF distance between the two graphs.</p> Source code in <code>pyfglt/fglt.py</code> <pre><code>@typechecked\ndef compute_rgf_distance(df_g1:pd.DataFrame, df_g2:pd.DataFrame) -&gt; float:\n    \"\"\"Relative Graphlet Frequency (RGF)\n\n    Args:\n        df_g1 (pd.DataFrame): Orbit counts for Graph 1 (rows=vertices, columns=orbits).\n        df_g2 (pd.DataFrame): Orbit counts for Graph 2 (rows=vertices, columns=orbits).\n\n    Compute the Relative Graphlet Frequency (RGF) distance between two graphs\n    represented by DataFrames of orbit counts.\n\n    Returns:\n        d (float): The RGF distance between the two graphs.\n    \"\"\"\n\n    # Sum of orbit counts across all vertices for each orbit\n    orbit_sums_g1 = df_g1.sum(axis=0)  # Series of length = number_of_orbits\n    orbit_sums_g2 = df_g2.sum(axis=0)\n\n    # Compute total counts\n    total_g1 = orbit_sums_g1.sum()\n    total_g2 = orbit_sums_g2.sum()\n\n    # Relative frequencies for each orbit\n    rel_freq_g1 = orbit_sums_g1 / total_g1 if total_g1 != 0 else orbit_sums_g1 * 0\n    rel_freq_g2 = orbit_sums_g2 / total_g2 if total_g2 != 0 else orbit_sums_g2 * 0\n\n    # RGF distance = sum of absolute differences\n    rgf_distance = np.sum(np.abs(rel_freq_g1 - rel_freq_g2))\n    return rgf_distance\n</code></pre>"},{"location":"api/#pyfglt.fglt.gcm_distance","title":"<code>gcm_distance(gcm1, gcm2)</code>","text":"<p>Compute a simple distance between two correlation matrices. For instance, the sum of absolute differences (L1 distance).</p> <p>Parameters:</p> Name Type Description Default <code>gcm1</code> <code>DataFrame</code> <p>GCM of the first graph</p> required <code>gcm2</code> <code>DataFrame</code> <p>GCM of the second graph</p> required <p>Returns:</p> Name Type Description <code>d</code> <code>float</code> <p>A distance measure between the two GCMs.</p> Source code in <code>pyfglt/fglt.py</code> <pre><code>@typechecked\ndef gcm_distance(gcm1:pd.DataFrame, gcm2:pd.DataFrame):\n    \"\"\"\n    Compute a simple distance between two correlation matrices.\n    For instance, the sum of absolute differences (L1 distance).\n\n    Args:\n        gcm1 (pd.DataFrame): GCM of the first graph\n        gcm2 (pd.DataFrame): GCM of the second graph\n\n    Returns:\n        d (float): A distance measure between the two GCMs.\n    \"\"\"\n    diff = gcm1.values - gcm2.values\n    return np.sum(np.abs(diff))\n</code></pre>"},{"location":"tutorial/01-getting-started/","title":"Getting started: usage","text":"<p>We provide a case study of the Fast Graphlet Transform, using Karate club, a small real-world dataset.</p>"},{"location":"tutorial/01-getting-started/#prerequisites","title":"Prerequisites","text":"<p>You need to install the following packages for this demo.</p> <pre><code>pip install pyfglt networkx matplotlib seaborn\n</code></pre>"},{"location":"tutorial/01-getting-started/#karate-club","title":"Karate Club","text":"<p>We will use Zachary\u2019s Karate Club graph for the demonstration.</p> <p>Zachary W. (1977). An information flow model for conflict and fission in small groups. Journal of Anthropological Research, 33, 452-473.</p>"},{"location":"tutorial/01-getting-started/#load-network","title":"Load network","text":"<pre><code>import networkx as nx\nimport matplotlib.pyplot as plt\n\nseed = 0  # seed random number generators for reproducibility\n\nG = nx.karate_club_graph()\n\npos = nx.spring_layout(G, seed=seed)\n\nfig, ax = plt.subplots()\n\nnx.draw_networkx_nodes(G, pos, ax=ax, node_size=20)\nnx.draw_networkx_edges(G, pos, ax=ax, alpha=0.4)\n\nplt.show()\n</code></pre>"},{"location":"tutorial/01-getting-started/#compute-fast-graphlet-transform","title":"Compute fast graphlet transform","text":"Table\u00a01: Astronomical object  <pre><code>import pyfglt.fglt as fg\n\nF = fg.compute(G)\n</code></pre> <p>The returned object is a dataframe where rows correspond to nodes and columns to the 16 graphlets up to 4-node graphlets. For example, we can see the number of each graphlet incident to the first 5 nodes:</p> <pre><code>F.head()\n</code></pre> Node id (0-based) [0] vertex (==1) [1] degree [2] 2-path [3] bifork [4] 3-cycle [5] 3-path, end [6] 3-path, interior [7] claw, leaf [8] claw, root [9] paw, handle [10] paw, base [11] paw, center [12] 4-cycle [13] diamond, off-cord [14] diamond, on-cord [15] 4-clique 0 1 16 17 102 18 81 197 13 352 6 34 171 10 2 30 7 1 1 9 19 24 12 73 56 33 32 8 80 27 6 2 18 7 2 1 10 34 34 11 72 179 84 54 17 75 51 20 6 8 7 3 1 6 20 5 10 49 11 56 1 5 81 5 0 4 7 7 4 1 3 16 1 2 17 1 64 0 15 25 0 1 2 1 0"},{"location":"tutorial/01-getting-started/#visualize-graphlet-distributions","title":"Visualize graphlet distributions","text":"<pre><code>import seaborn as sns\npg = sns.PairGrid(F.iloc[:,1:5])\npg.map_diag(sns.histplot, fill=False, bins = 20)\npg.map_upper(sns.scatterplot)\npg.map_lower(sns.histplot, bins = 20)\n</code></pre>"},{"location":"tutorial/02-graphlet-based-network-properties/","title":"Graphlet-based network properties","text":""},{"location":"tutorial/02-graphlet-based-network-properties/#setup","title":"Setup","text":"<p>You need to install the following packages for this demo.</p> <pre><code>pip install pyfglt networkx pandas numpy\n</code></pre> <p>We\u2019ll create three graphs as running examples in this tutorial.</p> <pre><code>import numpy as np\nimport pandas as pd\nimport networkx as nx\n\nG1 = nx.barabasi_albert_graph(500, 7, seed = 0)\nG2 = nx.barabasi_albert_graph(1000, 8, seed = 1)\nG3 = nx.watts_strogatz_graph(750, 7, 0.02, seed = 0)\n</code></pre> <p>We then compute the graphlet frequencies for each network.</p> <pre><code>import pyfglt.fglt as fg\n\nF1 = fg.compute(G1)\nF2 = fg.compute(G2)\nF3 = fg.compute(G3)\n</code></pre>"},{"location":"tutorial/02-graphlet-based-network-properties/#relative-graphlet-frequency-rgf-distance","title":"Relative graphlet frequency (RGF) distance","text":"<p>The Relative Graphlet Frequency of an orbit is the frequency of that orbit (summing across all vertices) divided by the sum of all orbit frequencies in the graph.</p> <p>RGF Distance between two graphs \\(G\\) and \\(H\\) for orbits \\(\\{1,\\ldots,16\\}\\) can be defined as:</p> \\[ d_{\\text{RGF}}(G,H) \\;=\\; \\sum_{k=1}^{16} \\left\\lvert \\frac{F_G(k)}{\\sum_{j=1}^{16} F_G(j)} \\;-\\; \\frac{F_H(k)}{\\sum_{j=1}^{16} F_H(j)} \\right\\rvert \\] <p>where \\(F_G(k)\\) is the sum of orbit \\(k\\) counts across all vertices in graph \\(G\\).</p> <pre><code>rgf_dist = np.zeros((3,3))\nfor i,Fa in enumerate( [F1, F2, F3] ):\n    for j,Fb in enumerate( [F1, F2, F3] ):\n        rgf_dist[i,j] = fg.compute_rgf_distance(Fa, Fb)\n</code></pre> G1 G2 G3 G1 0 0.108194 0.8892 G2 0.108194 0 0.939122 G3 0.8892 0.939122 0"},{"location":"tutorial/02-graphlet-based-network-properties/#graphlet-degree-distribution-gdd-agreement","title":"Graphlet degree distribution (GDD) agreement","text":"<p>The Graphlet Degree of a vertex for a specific orbit is the number of times that vertex touches (or participates in) that orbit. Given the orbit counts in the DataFrame, each column is effectively the graphlet degree for each vertex across an orbit.</p> <p>To measure GDD Agreement between two graphs, one approach (inspired by GraphCrunch2) is:</p> <ol> <li>For each orbit \\(i\\) (from 1 to 16):<ul> <li>Build the distribution (histogram) of the graphlet degrees \\(d^G_i\\)   across all vertices in graph \\(G\\).  </li> <li>Same for graph \\(H\\).  </li> </ul> </li> <li>Compare these two distributions using an overlap measure. For     discrete distributions \\(P_i^G\\) and \\(P_i^H\\): $$     \\text{Overlap}(P_i^G, P_i^H) = \\sum_k \\min\\bigl(P_i^G(k), P_i^H(k)\\bigr)     $$ where \\(P_i^G(k)\\) is the fraction of vertices in \\(G\\) that have     graphlet degree \\(k\\) for orbit \\(i\\).  </li> <li>Average this overlap across all orbits: $$     \\text{GDD-Agreement}(G,H) = \\frac{1}{16} \\sum_{i=1}^{16} \\text{Overlap}(P_i^G, P_i^H).     $$</li> </ol> <p>This yields a value in \\([0, 1]\\), where 1 means perfect agreement of distributions.</p> <pre><code>gdd_agree = np.zeros((3,3))\nfor i,Fa in enumerate( [F1, F2, F3] ):\n    for j,Fb in enumerate( [F1, F2, F3] ):\n        gdd_agree[i,j] = fg.compute_gdd_agreement(Fa, Fb)\n</code></pre> G1 G2 G3 G1 1 0.523313 0.123542 G2 0.523313 1 0.115167 G3 0.123542 0.115167 1"},{"location":"tutorial/02-graphlet-based-network-properties/#graphlet-correlation-matrix-gcm","title":"Graphlet Correlation Matrix (GCM)","text":"<p>The Graphlet Correlation Matrix (GCM) captures correlations (usually Spearman or Pearson) between different orbits across the vertices. Essentially:</p> \\[ GCM(G) \\quad=\\quad \\Bigl(\\rho_{i,j}\\Bigr)_{1 \\le i,j \\le 16} \\] <p>where \\(\\rho_{i,j}\\) is the correlation (e.g., Spearman) between the i-th orbit degrees and the j-th orbit degrees across all vertices in graph \\(G\\).</p> <pre><code>gcm1 = fg.compute_graphlet_correlation_matrix(F1, method='spearman')\ngcm2 = fg.compute_graphlet_correlation_matrix(F2, method='spearman')\ngcm3 = fg.compute_graphlet_correlation_matrix(F3, method='spearman')\n</code></pre>"},{"location":"tutorial/02-graphlet-based-network-properties/#gcm-example","title":"GCM example","text":"<p>We now have the correlation matrix (GCM) for each graph. The GCM for graph <code>G1</code> is shown below</p> [1] degree [2] 2-path [3] bifork [4] 3-cycle [5] 3-path, end [6] 3-path, interior [7] claw, leaf [8] claw, root [9] paw, handle [10] paw, base [11] paw, center [12] 4-cycle [13] diamond, off-cord [14] diamond, on-cord [15] 4-clique [1] degree 1 0.797489 0.99255 0.721824 0.850319 0.957717 0.59164 0.987567 0.591097 0.662774 0.866555 0.865433 0.590136 0.683471 0.537678 [2] 2-path 0.797489 1 0.75209 0.858184 0.980674 0.917015 0.922261 0.738192 0.906362 0.886047 0.879049 0.938975 0.859091 0.817937 0.66163 [3] bifork 0.99255 0.75209 1 0.64882 0.810571 0.940231 0.537775 0.9985 0.539182 0.588904 0.813029 0.842782 0.519062 0.618533 0.502792 [4] 3-cycle 0.721824 0.858184 0.64882 1 0.850729 0.76346 0.782988 0.627428 0.773249 0.962727 0.951642 0.766913 0.893846 0.952637 0.712615 [5] 3-path, end 0.850319 0.980674 0.810571 0.850729 1 0.944489 0.855183 0.797396 0.855218 0.851695 0.898804 0.969354 0.817382 0.804315 0.638269 [6] 3-path, interior 0.957717 0.917015 0.940231 0.76346 0.944489 1 0.747828 0.933315 0.738758 0.739955 0.884068 0.952221 0.686035 0.719056 0.564356 [7] claw, leaf 0.59164 0.922261 0.537775 0.782988 0.855183 0.747828 1 0.523431 0.983409 0.87542 0.740177 0.788411 0.888326 0.76362 0.672914 [8] claw, root 0.987567 0.738192 0.9985 0.627428 0.797396 0.933315 0.523431 1 0.525663 0.568635 0.795132 0.833967 0.500084 0.601525 0.488454 [9] paw, handle 0.591097 0.906362 0.539182 0.773249 0.855218 0.738758 0.983409 0.525663 1 0.865189 0.732816 0.788529 0.882963 0.757707 0.667036 [10] paw, base 0.662774 0.886047 0.588904 0.962727 0.851695 0.739955 0.87542 0.568635 0.865189 1 0.894069 0.753967 0.957287 0.935547 0.729429 [11] paw, center 0.866555 0.879049 0.813029 0.951642 0.898804 0.884068 0.740177 0.795132 0.732816 0.894069 1 0.852875 0.813447 0.878809 0.645709 [12] 4-cycle 0.865433 0.938975 0.842782 0.766913 0.969354 0.952221 0.788411 0.833967 0.788529 0.753967 0.852875 1 0.709944 0.721873 0.570544 [13] diamond, off-cord 0.590136 0.859091 0.519062 0.893846 0.817382 0.686035 0.888326 0.500084 0.882963 0.957287 0.813447 0.709944 1 0.877049 0.731786 [14] diamond, on-cord 0.683471 0.817937 0.618533 0.952637 0.804315 0.719056 0.76362 0.601525 0.757707 0.935547 0.878809 0.721873 0.877049 1 0.688793 [15] 4-clique 0.537678 0.66163 0.502792 0.712615 0.638269 0.564356 0.672914 0.488454 0.667036 0.729429 0.645709 0.570544 0.731786 0.688793 1 <p>If we want to measure how similar or different the GCMs are between two graphs, we can compute a matrix distance (e.g., Frobenius norm of the difference, or sum of absolute differences, etc.):</p> <pre><code>dist_gcm = np.zeros((3,3))\nfor i,Fa in enumerate( [gcm1, gcm2, gcm3] ):\n    for j,Fb in enumerate( [gcm1, gcm2, gcm3] ):\n        dist_gcm[i,j] = fg.gcm_distance(Fa, Fb)\n</code></pre> G1 G2 G3 G1 0 4.33726 131.925 G2 4.33726 0 130.265 G3 131.925 130.265 0"},{"location":"tutorial/02-graphlet-based-network-properties/#summary","title":"Summary","text":"<ul> <li>RGF Distance: Captures how different the relative orbit   frequencies are between two graphs.  </li> <li>GDD Agreement: Measures how similarly the two graphs\u2019 vertices   distribute their orbit degrees.  </li> <li>GCM: Captures how orbits co-vary (correlate) within a single   graph, and can also be compared across graphs.</li> </ul> <p>These measures are widely used in graphlet-based network comparison (e.g., Netdis, GraphCrunch2, etc.). Modify these examples to suit your exact needs (e.g., weighting orbits differently, using different correlation measures, etc.).</p>"}]}